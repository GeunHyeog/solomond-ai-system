#!/usr/bin/env python3
"""
üß† Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î™®ÎãàÌÑ∞ÎßÅ Î∞è ÏµúÏ†ÅÌôî ÏãúÏä§ÌÖú
Ïã§ÏãúÍ∞Ñ Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞ÎßÅ, ÏûêÎèô Ï†ïÎ¶¨, ÏµúÏ†ÅÌôî ÏïåÍ≥†Î¶¨Ï¶ò Íµ¨ÌòÑ
"""

import psutil
import gc
import os
import time
import json
import threading
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
import subprocess

@dataclass
class MemorySnapshot:
    """Î©îÎ™®Î¶¨ Ïä§ÎÉÖÏÉ∑ ÌÅ¥ÎûòÏä§"""
    timestamp: datetime
    total_memory_gb: float
    available_memory_gb: float
    used_memory_gb: float
    memory_percent: float
    swap_total_gb: float
    swap_used_gb: float
    swap_percent: float
    
    def to_dict(self):
        return {
            'timestamp': self.timestamp.isoformat(),
            'total_memory_gb': self.total_memory_gb,
            'available_memory_gb': self.available_memory_gb,
            'used_memory_gb': self.used_memory_gb,
            'memory_percent': self.memory_percent,
            'swap_total_gb': self.swap_total_gb,
            'swap_used_gb': self.swap_used_gb,
            'swap_percent': self.swap_percent
        }

@dataclass
class ProcessMemoryInfo:
    """ÌîÑÎ°úÏÑ∏Ïä§ Î©îÎ™®Î¶¨ Ï†ïÎ≥¥ ÌÅ¥ÎûòÏä§"""
    pid: int
    name: str
    cmdline: str
    memory_mb: float
    memory_percent: float
    cpu_percent: float
    port: Optional[int] = None
    is_streamlit: bool = False
    
class MemoryOptimizer:
    """Î©îÎ™®Î¶¨ ÏµúÏ†ÅÌôî Î∞è Î™®ÎãàÌÑ∞ÎßÅ ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, monitoring_interval: int = 30):
        self.monitoring_interval = monitoring_interval
        self.history_file = Path(__file__).parent / "memory_history.json"
        self.config_file = Path(__file__).parent / "memory_config.json"
        self.log_file = Path(__file__).parent / "memory_optimizer.log"
        
        self.memory_history: List[Dict] = []
        self.is_monitoring = False
        self.monitor_thread = None
        
        # ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï
        self.thresholds = {
            'memory_warning': 80.0,    # 80% Ïù¥ÏÉÅÏãú Í≤ΩÍ≥†
            'memory_critical': 90.0,   # 90% Ïù¥ÏÉÅÏãú ÏúÑÌóò
            'process_high_usage': 500.0,  # ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä 500MB Ïù¥ÏÉÅ ÏÇ¨Ïö©Ïãú
            'cleanup_trigger': 85.0,   # 85% Ïù¥ÏÉÅÏãú ÏûêÎèô Ï†ïÎ¶¨
        }
        
        self.load_config()
        self.load_history()
    
    def load_config(self):
        """ÏÑ§Ï†ï Î°úÎìú"""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    self.thresholds.update(config.get('thresholds', {}))
            except Exception:
                pass
    
    def save_config(self):
        """ÏÑ§Ï†ï Ï†ÄÏû•"""
        try:
            config = {
                'thresholds': self.thresholds,
                'last_updated': datetime.now().isoformat()
            }
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(config, f, indent=2)
        except Exception:
            pass
    
    def load_history(self):
        """Î©îÎ™®Î¶¨ ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú"""
        if self.history_file.exists():
            try:
                with open(self.history_file, 'r', encoding='utf-8') as f:
                    self.memory_history = json.load(f)
                    # 24ÏãúÍ∞Ñ Ïù¥Ï†Ñ Îç∞Ïù¥ÌÑ∞ Ï†ïÎ¶¨
                    cutoff_time = datetime.now() - timedelta(hours=24)
                    self.memory_history = [
                        entry for entry in self.memory_history
                        if datetime.fromisoformat(entry['timestamp']) > cutoff_time
                    ]
            except Exception:
                self.memory_history = []
    
    def save_history(self):
        """Î©îÎ™®Î¶¨ ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû•"""
        try:
            with open(self.history_file, 'w', encoding='utf-8') as f:
                json.dump(self.memory_history[-1000:], f, indent=2)  # ÏµúÍ∑º 1000Í∞úÎßå Ï†ÄÏû•
        except Exception:
            pass
    
    def log(self, message: str, level: str = "INFO"):
        """Î°úÍ∑∏ Í∏∞Î°ù"""
        try:
            with open(self.log_file, 'a', encoding='utf-8') as f:
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                f.write(f"[{timestamp}] [{level}] {message}\n")
        except Exception:
            pass
    
    def get_memory_snapshot(self) -> MemorySnapshot:
        """ÌòÑÏû¨ Î©îÎ™®Î¶¨ ÏÉÅÌÉú Ïä§ÎÉÖÏÉ∑"""
        memory = psutil.virtual_memory()
        swap = psutil.swap_memory()
        
        return MemorySnapshot(
            timestamp=datetime.now(),
            total_memory_gb=round(memory.total / 1024**3, 2),
            available_memory_gb=round(memory.available / 1024**3, 2),
            used_memory_gb=round(memory.used / 1024**3, 2),
            memory_percent=round(memory.percent, 1),
            swap_total_gb=round(swap.total / 1024**3, 2),
            swap_used_gb=round(swap.used / 1024**3, 2),
            swap_percent=round(swap.percent, 1)
        )
    
    def get_streamlit_processes(self) -> List[ProcessMemoryInfo]:
        """Streamlit ÌîÑÎ°úÏÑ∏Ïä§ Î©îÎ™®Î¶¨ Ï†ïÎ≥¥"""
        streamlit_processes = []
        
        for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'memory_info', 'cpu_percent']):
            try:
                cmdline = " ".join(proc.info['cmdline']) if proc.info['cmdline'] else ""
                
                if 'streamlit' in cmdline.lower() or 'streamlit' in proc.info['name'].lower():
                    memory_mb = proc.info['memory_info'].rss / 1024 / 1024
                    
                    # Ìè¨Ìä∏ Ï∂îÏ∂ú ÏãúÎèÑ
                    port = None
                    try:
                        for conn in proc.connections():
                            if (conn.status == psutil.CONN_LISTEN and 
                                conn.laddr and 
                                8500 <= conn.laddr.port <= 8600):
                                port = conn.laddr.port
                                break
                    except Exception:
                        pass
                    
                    process_info = ProcessMemoryInfo(
                        pid=proc.info['pid'],
                        name=proc.info['name'],
                        cmdline=cmdline,
                        memory_mb=round(memory_mb, 1),
                        memory_percent=round(memory_mb / (psutil.virtual_memory().total / 1024 / 1024) * 100, 2),
                        cpu_percent=proc.info['cpu_percent'] or 0.0,
                        port=port,
                        is_streamlit=True
                    )
                    
                    streamlit_processes.append(process_info)
                    
            except (psutil.NoSuchProcess, psutil.AccessDenied):
                continue
        
        return sorted(streamlit_processes, key=lambda x: x.memory_mb, reverse=True)
    
    def analyze_memory_usage(self) -> Dict:
        """Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Î∂ÑÏÑù"""
        snapshot = self.get_memory_snapshot()
        processes = self.get_streamlit_processes()
        
        total_streamlit_memory = sum(p.memory_mb for p in processes)
        high_usage_processes = [p for p in processes if p.memory_mb > self.thresholds['process_high_usage']]
        
        # Î©îÎ™®Î¶¨ ÏÉÅÌÉú ÌåêÏ†ï
        status = "Ï†ïÏÉÅ"
        if snapshot.memory_percent >= self.thresholds['memory_critical']:
            status = "ÏúÑÌóò"
        elif snapshot.memory_percent >= self.thresholds['memory_warning']:
            status = "Í≤ΩÍ≥†"
        
        # ÏµúÏ†ÅÌôî Í∂åÏû•ÏÇ¨Ìï≠
        recommendations = []
        
        if snapshot.memory_percent > self.thresholds['memory_warning']:
            recommendations.append("ÏãúÏä§ÌÖú Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§")
        
        if high_usage_processes:
            recommendations.append(f"{len(high_usage_processes)}Í∞ú ÌîÑÎ°úÏÑ∏Ïä§Í∞Ä Í≥ºÎèÑÌïú Î©îÎ™®Î¶¨Î•º ÏÇ¨Ïö© Ï§ë")
        
        if total_streamlit_memory > 1000:  # 1GB Ïù¥ÏÉÅ
            recommendations.append("Streamlit Ïï±Îì§Ïùò Ï¥ù Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§")
        
        if snapshot.swap_percent > 50:
            recommendations.append("Ïä§Ïôë Î©îÎ™®Î¶¨ ÏÇ¨Ïö©ÎüâÏù¥ ÎÜíÏäµÎãàÎã§")
        
        return {
            'snapshot': snapshot.to_dict(),
            'processes': [asdict(p) for p in processes],
            'total_streamlit_memory_mb': round(total_streamlit_memory, 1),
            'high_usage_processes': len(high_usage_processes),
            'status': status,
            'recommendations': recommendations,
            'analysis_time': datetime.now().isoformat()
        }
    
    def perform_memory_cleanup(self) -> Dict[str, any]:
        """Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏàòÌñâ"""
        self.log("Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏãúÏûë")
        cleanup_results = {}
        
        # 1. Python Í∞ÄÎπÑÏßÄ Ïª¨Î†âÏÖò
        before_gc = len(gc.get_objects())
        collected = gc.collect()
        after_gc = len(gc.get_objects())
        cleanup_results['garbage_collection'] = {
            'objects_before': before_gc,
            'objects_after': after_gc,
            'collected': collected
        }
        
        # 2. ÏãúÏä§ÌÖú Ï∫êÏãú Ï†ïÎ¶¨ ÏãúÎèÑ (Windows)
        try:
            if os.name == 'nt':  # Windows
                subprocess.run(['sfc', '/scannow'], capture_output=True, timeout=30)
                cleanup_results['system_cache'] = "ÏãúÎèÑÎê®"
        except Exception:
            cleanup_results['system_cache'] = "Ïã§Ìå®"
        
        # 3. ÎÜíÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö© ÌîÑÎ°úÏÑ∏Ïä§ ÌôïÏù∏
        high_memory_processes = []
        for proc in self.get_streamlit_processes():
            if proc.memory_mb > self.thresholds['process_high_usage']:
                high_memory_processes.append({
                    'pid': proc.pid,
                    'port': proc.port,
                    'memory_mb': proc.memory_mb,
                    'name': proc.name
                })
        
        cleanup_results['high_memory_processes'] = high_memory_processes
        
        # Ï†ïÎ¶¨ ÌõÑ Î©îÎ™®Î¶¨ ÏÉÅÌÉú
        after_snapshot = self.get_memory_snapshot()
        cleanup_results['after_cleanup'] = after_snapshot.to_dict()
        
        self.log(f"Î©îÎ™®Î¶¨ Ï†ïÎ¶¨ ÏôÑÎ£å: {len(high_memory_processes)}Í∞ú Í≥†ÏÇ¨Ïö© ÌîÑÎ°úÏÑ∏Ïä§ Î∞úÍ≤¨")
        return cleanup_results
    
    def start_monitoring(self):
        """Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë"""
        if self.is_monitoring:
            return
        
        self.is_monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        self.monitor_thread.start()
        self.log("Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë")
    
    def stop_monitoring(self):
        """Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ"""
        self.is_monitoring = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=5)
        self.log("Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ")
    
    def _monitoring_loop(self):
        """Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ"""
        while self.is_monitoring:
            try:
                analysis = self.analyze_memory_usage()
                self.memory_history.append(analysis)
                
                # ÏûêÎèô Ï†ïÎ¶¨ Ìä∏Î¶¨Í±∞
                memory_percent = analysis['snapshot']['memory_percent']
                if memory_percent >= self.thresholds['cleanup_trigger']:
                    self.log(f"Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ {memory_percent}% - ÏûêÎèô Ï†ïÎ¶¨ Ïã§Ìñâ")
                    self.perform_memory_cleanup()
                
                # ÌûàÏä§ÌÜ†Î¶¨ Ï†ÄÏû• (5Î∂ÑÎßàÎã§)
                if len(self.memory_history) % 10 == 0:
                    self.save_history()
                
                time.sleep(self.monitoring_interval)
                
            except Exception as e:
                self.log(f"Î™®ÎãàÌÑ∞ÎßÅ Ïò§Î•ò: {e}", "ERROR")
                time.sleep(60)  # Ïò§Î•òÏãú 1Î∂Ñ ÎåÄÍ∏∞
    
    def get_memory_trends(self, hours: int = 4) -> Dict:
        """Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ Ìä∏Î†åÎìú Î∂ÑÏÑù"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        recent_history = [
            entry for entry in self.memory_history
            if datetime.fromisoformat(entry['analysis_time']) > cutoff_time
        ]
        
        if not recent_history:
            return {'error': 'ÌûàÏä§ÌÜ†Î¶¨ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå'}
        
        memory_values = [entry['snapshot']['memory_percent'] for entry in recent_history]
        streamlit_memory = [entry['total_streamlit_memory_mb'] for entry in recent_history]
        
        return {
            'period_hours': hours,
            'data_points': len(recent_history),
            'memory_percent': {
                'min': min(memory_values),
                'max': max(memory_values),
                'avg': round(sum(memory_values) / len(memory_values), 1),
                'current': memory_values[-1] if memory_values else 0
            },
            'streamlit_memory_mb': {
                'min': min(streamlit_memory),
                'max': max(streamlit_memory),
                'avg': round(sum(streamlit_memory) / len(streamlit_memory), 1),
                'current': streamlit_memory[-1] if streamlit_memory else 0
            },
            'trend_direction': self._calculate_trend(memory_values[-10:]) if len(memory_values) >= 10 else 'stable'
        }
    
    def _calculate_trend(self, values: List[float]) -> str:
        """Ìä∏Î†åÎìú Î∞©Ìñ• Í≥ÑÏÇ∞"""
        if len(values) < 2:
            return 'stable'
        
        first_half = sum(values[:len(values)//2]) / (len(values)//2)
        second_half = sum(values[len(values)//2:]) / (len(values) - len(values)//2)
        
        diff = second_half - first_half
        if diff > 2:
            return 'increasing'
        elif diff < -2:
            return 'decreasing'
        else:
            return 'stable'
    
    def force_restart_high_memory_process(self, memory_threshold_mb: float = 1000) -> Dict:
        """ÎÜíÏùÄ Î©îÎ™®Î¶¨ ÏÇ¨Ïö© ÌîÑÎ°úÏÑ∏Ïä§ Í∞ïÏ†ú Ïû¨ÏãúÏûë"""
        results = {}
        high_memory_processes = []
        
        for proc in self.get_streamlit_processes():
            if proc.memory_mb > memory_threshold_mb and proc.port:
                high_memory_processes.append(proc)
        
        if not high_memory_processes:
            return {'message': f'{memory_threshold_mb}MB Ïù¥ÏÉÅ ÏÇ¨Ïö©ÌïòÎäî ÌîÑÎ°úÏÑ∏Ïä§ ÏóÜÏùå'}
        
        from .port_manager import PortManager
        port_manager = PortManager()
        
        for proc in high_memory_processes:
            try:
                # ÌîÑÎ°úÏÑ∏Ïä§ Ï¢ÖÎ£å
                psutil.Process(proc.pid).terminate()
                time.sleep(2)
                
                # Ìè¨Ìä∏ Îß§ÎãàÏ†ÄÎ•º ÌÜµÌï¥ Ïû¨ÏãúÏûë ÏãúÎèÑ
                module_key = f"port_{proc.port}"
                restarted = port_manager.restart_module_on_port(module_key, proc.port)
                
                results[f"port_{proc.port}"] = {
                    'old_memory_mb': proc.memory_mb,
                    'restarted': restarted,
                    'action': 'terminated_and_restarted' if restarted else 'terminated_only'
                }
                
                self.log(f"ÎÜíÏùÄ Î©îÎ™®Î¶¨ ÌîÑÎ°úÏÑ∏Ïä§ Ïû¨ÏãúÏûë: Ìè¨Ìä∏ {proc.port}, {proc.memory_mb}MB")
                
            except Exception as e:
                results[f"port_{proc.port}"] = {
                    'error': str(e),
                    'action': 'failed'
                }
                self.log(f"ÌîÑÎ°úÏÑ∏Ïä§ Ïû¨ÏãúÏûë Ïã§Ìå® Ìè¨Ìä∏ {proc.port}: {e}", "ERROR")
        
        return results

def main():
    """ÌÖåÏä§Ìä∏ Ïã§Ìñâ"""
    optimizer = MemoryOptimizer()
    
    print("Memory Optimizer Test")
    print("=" * 50)
    
    # ÌòÑÏû¨ Î©îÎ™®Î¶¨ Î∂ÑÏÑù
    analysis = optimizer.analyze_memory_usage()
    
    print(f"Memory Status: {analysis['status']}")
    print(f"Memory Usage: {analysis['snapshot']['memory_percent']}%")
    print(f"Total Streamlit Memory: {analysis['total_streamlit_memory_mb']} MB")
    print(f"High Usage Processes: {analysis['high_usage_processes']}")
    
    print(f"\nStreamlit Processes ({len(analysis['processes'])}):")
    for proc in analysis['processes']:
        port_info = f":{proc['port']}" if proc['port'] else ""
        print(f"  PID {proc['pid']}{port_info} - {proc['memory_mb']} MB")
    
    if analysis['recommendations']:
        print(f"\nRecommendations:")
        for rec in analysis['recommendations']:
            print(f"  - {rec}")
    
    # Ï†ïÎ¶¨ ÏàòÌñâ
    print(f"\nPerforming cleanup...")
    cleanup_results = optimizer.perform_memory_cleanup()
    print(f"Cleanup completed")

if __name__ == "__main__":
    main()